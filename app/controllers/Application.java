package controllers;

import actions.BasicAuth;
import com.fasterxml.jackson.databind.JsonNode;
import models.Fach;
import models.FachRepository;
import play.libs.Json;
import play.mvc.*;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import java.util.List;

/**
 * The main set of web services.
 */
@Named
@Singleton
@With(BasicAuth.class)
public class Application extends Controller {

    private final FachRepository fachRepository;

    // We are using constructor injection to receive a repository to support our desire for immutability.
    @Inject
    public Application(final FachRepository fachRepository) {
        this.fachRepository = fachRepository;
    }

    public Result index() {

        // For fun we save a new person and then find that one we've just saved. The id is auto generated by
        // the db so we know that we're round-tri0ping to the db and back in order to demonstrate something
        // interesting. Spring Data takes care of transactional concerns and the following code is all
        // executed on the same thread (a requirement of the JPA entity manager).

        return ok("");
    }

    public Result getFachJSON() {

        // For fun we save a new person and then find that one we've just saved. The id is auto generated by
        // the db so we know that we're round-tripping to the db and back in order to demonstrate something
        // interesting. Spring Data takes care of transactional concerns and the following code is all
        // executed on the same thread (a requirement of the JPA entity manager).

        final Fach fach = new Fach();
        fach.name = "Mathe";
        fachRepository.save(fach);
        // Deliver the index page with a message showing the id that was generated.

        return ok(Json.toJson(fachRepository.findAll()));
        //return ok(views.html.index.render("Found id: " + retrievedPerson.id + " of person/people"));
        ///return ok(views.html.index.render(retrievedPerson));
    }
}

